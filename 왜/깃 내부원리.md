# 깃 내부원리

## 깃은 DB가 어떻게 되어있을까

### 로컬, 네트워크 둘 다 됨

생각해보면 깃은 푸시는 할 순 없지만 로컬에서도 잘 돌아감 <- 그 이유는 src/.git에 깃의 DB가 있기 때문임

-> 이렇게 때문에 분산형 DB라고 볼 수 있음

### CR DB

내가 아는 DB는 CRUD가 기능을 기본으로 달고 시작하는데 깃의 DB는 CR까지 밖에 안 되는 반쪽짜리 DB임 -> 수정, 삭제가 안 됨 ㅋㅋㅋ

-> 이렇게 만든 이유는 간단함, 깃 자체가 히스토리를 하나도 잃어버리지 않게 하기 위해 만들어져서 그럼. 

-> 그래서 막 stackoverflow에 aws 펌키 올렸는데 지워서 없거든요? 괜찮겠죠? 이런글 올라오는데 그러면 걍 레포를 삭제해야 됨

-> 깃에는 삭제라는 기능이 없고 그냥 그 위에 덮어씌우는 것. 해시값만 있으면 언제든지 복구가능

### Key value DB

깃 DB는 Key - value 스토리지(키를 통해 벨류로 접근하는 방식)로 되어 있음

#### 키는 어케 만들까

키를 만드는 알고리즘은 해싱을 하는거임

blahblah.file -> 해싱 -> [ 해시값 == 키 ] -> 파일의 내용을 값으로 가짐

| 키     | 벨류        |
| :----- | :---------- |
| a1     | `var a = 1` |
| a2     | `var a = 2` |
| ...... | ......      |

* 깃을 쓰지 않고도 깃 DB에 데이터를 저장할수도 있다고 함 근데 보통은 그렇게 안 함



## 커밋은 어떻게 동작할까

### 커밋이 뭘까 

위에 DB에 대한 내용을 보면 커밋은 해싱해서 키를 얻고 -> 키와 벨류를 깃 DB에 넣는 행위임

### 코드 내용이 동일하면은?

파일의 내용이 동일하면 해시값도 동일함 -> 깃은 중복되는 내용을 다시 새롭게 저장하지는 않음

### 뭐야 근데 해시는 무슨 알고리즘 써

해시 값은 40자임. 40자라는 얘기는 160비트..... (SHA1)

### 구조는요

```src: { hash: children: [ a.file : a1, b.file :a2, c.file: a1 ] }```

만약에 Json 형태로 (ㄹㅇ로 Json은 아님) 문자열을 해싱해서 src의 커밋 해시 값을 만듦 

-> 깃은 파일 구조를 저장하기 위해 트리 구조를 이용함 

-> 이 때 트리는 각각의 트리로 하위 1레벨의 트리구조를 가짐

-> 결국 커밋 해시 값 타고 가다보면 

-> 파일 구조를 복원할 수 있는 원리 (와우 신기해용~)

### 커밋 구성요소

1. 루트 트리의 해시 값 : 위에서 설명한 트리임
2. 메타정보 : 커밋 작성자, 날짜, 메시지 등등
3. 부모커밋의 해시값

#### 오잉? 부모 커밋의 해시값은 왜 가지고 있어

만약에 내가 window os를 개발하는 개발자라고 해보자

그러면 막 100만개 파일이 있을 수도 있는데 이거 커밋할 때마다 해싱해야 될까

-> ㄴㄴ 비효율적임 그래서 부모 커밋의 해시값을 가지고 있는것

-> 변경된 부분만 새로 해싱하고 나머지는 캐싱처리처럼 부모 커밋에서 가져옴

### 그럼 브랜치는 뭐야

브랜치는 파일의 형태로 이해하면 편함.

-> main 브랜치 이름을 쓰고 있으면 ``` .git/refs/head```에 main 파일이 들어 있음

-> 만약 해당 파일을 지우면 main 브랜치가 지워짐

### 태그

브랜치처럼 ``` .git/refs/tags```에 파일로 저장되어 있음

작업하다가 나중에 쓸거 같은 커밋은 따로 저장해두고 ```cherry-pick```해서 꺼내 쓸 수 있음



## 머지는 어떻게 동작하는걸까

양쪽 브랜치의 부모로 올라간 후 자식 커밋으로 이동하면서, 같은 파일 내에서 변경사항이 있는지 확인함

-> 이렇게 양쪽 브랜치의 부모로 올라가서 이동하다보니 두 개의 부모 커밋을 가짐 (배열형태)

-> 추가적으로, 변경사항을 확인하다 만약 다른 내용이 발견되면 conflict가 발생됨

-> 깃은 양쪽 코드 중 어느것이 옳은 코드인지 알 수 없으니 사람이 직접 해결해야 함



## Reset과 Rebase

### Reset

``` git reset commithash``` (commithash는 대충 40자의 커밋 해시 값이라 가정)를 하면 

-> 일단 먼저 프로젝트에 있는 모든 파일을 지움

-> 그 다음 커밋의 해시 값으로 루트 트리를 탐색 시작

-> 자식 트리를 계속 해서 탐색하면서

-> 결국 깃 DB에 있는 벨류를 키로 조회하고 꺼내옴

-> 이런식으로 해시 값 하나만으로 프로젝트가 복원이 됨

#### 만약에 -hard 키워드를 쓴다면?

--hard가 아닌 reset은 브랜치 파일 안의 커밋 해시 값 40자만 변경하지만

--hard가 붙어있으면 HEAD가 가리키는 깃 DB의 상태로 재구성 해버림

### Rebase

걍 base 커밋을 새로 잡는 것임

rebase를 쓰면 현재 작업 중인 브랜치를 머지하지 않고 한줄로 만들 수 있음

a 브랜치에서 ```git rebase b```를 하면 a와 b의 공통 부모를 찾음

-> 그러고 b 브랜치의 최신 커밋 이후로 a 브랜치의 커밋이 쌓임

-> 그러면 머지안하고 한줄완성~ 신기하네

#### -i (interactive) 활용하기

요거 활용 잘하면 좋은데 drop, reword, mixup, squash, edit 등의 키워드들이 있음

만약 당장 필요없는 커밋을 drop을 하면 그거 빼고 rebase 가능

다만 나중에 필요할 거 같다면 tag 붙여서 체리픽하면 좋음~



## 알쓸신잡

위에서도 설명했듯이 머지할 때 서로 다른 변경사항이 있을 때 conflict가 발생하는데

가끔은 conflict 그냥 컴퓨터가 알아서 해주면 안 될까라는 생각을 함

그런 사람들이 머리를 모아서 자동으로 conflict를 해결해주는 알고리즘을 만들었는데 그게 바로 '합의 알고리즘'임

이 합의 알고리즘의 예시로는 양쪽 파일 중 오른쪽 파일이 라인 수가 더 기니까 그냥 이걸로 채택~ 이런식

아무튼 지금까지 알아본 깃의 특징과 이 합의 알고리즘을 더 해서 블록체인과 연결해 생각해보면 굉장히 유사함

다만 블록체인에서는 이 커밋의 해시 값을 커밋할 때 생성하는 것이 아닌 미리 해시 값을 만들어둠

채굴이 바로 이 해시 값을 계산하는 행위임 오우.....

(자신만의 합의 알고리즘을 만들어서 적용시키면 그게 바로 당신만의 비트코인이 되는거야~)



